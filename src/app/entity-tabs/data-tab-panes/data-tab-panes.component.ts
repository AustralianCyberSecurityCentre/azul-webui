import {
  ChangeDetectionStrategy,
  Component,
  ElementRef,
  Input,
  OnDestroy,
  TemplateRef,
  inject,
} from "@angular/core";
import { faDownload, faXmark } from "@fortawesome/free-solid-svg-icons";
import { BehaviorSubject, Observable, Subscription, combineLatest } from "rxjs";
import * as ops from "rxjs/operators";

import { DomPortal, PortalModule } from "@angular/cdk/portal";
import { CommonModule } from "@angular/common";
import { HttpErrorResponse } from "@angular/common/http";
import { FontAwesomeModule } from "@fortawesome/angular-fontawesome";
import {
  AngularSplitModule,
  SplitAreaSize,
  SplitGutterInteractionEvent,
} from "angular-split";
import { ToastrService } from "ngx-toastr";
import { AzCommonModule } from "src/app/common/common.module";
import { EntityService } from "src/app/core/entity.service";
import { media } from "src/app/core/media";
import { ButtonSize, ButtonType } from "src/lib/flow/button/button.component";
import { FlowModule } from "src/lib/flow/flow.module";

interface ChildTab {
  /** Unique ID for the tab. Generated by the data-container. */
  tabId: string;
  /** Name for this tab. */
  name: string;
  /** Name for the tab that contains additional information that is acquired asynchronously. */
  /** Note: not part of name as it made for a more complicated API (you'd have to make an observable with an inital value set). */
  betterName$?: Observable<string>;
  /** The parent entity for this content. */
  downloadParent?: string;
  /** The hash for the content. */
  downloadHash?: string;
}

/** Startup specification for a tab. */
export interface TabSpec extends ChildTab {
  /** Reference to the DOM element to render. */
  template: ElementRef;
  /** If this tab is "interesting" - i.e it should be presented as a badge on Data. */
  interesting: boolean;
  /** If this tab should by default open in a specific pane. */
  openInPane?: number;
}

/** Runtime specification for a tab. */
interface RuntimeTab extends ChildTab {
  /** If this tab is open (or is minimised and only available in the sidebar). */
  open: boolean;
  /** Template to render for this tab. */
  portal: DomPortal;
  /** Which pane this tab wants to be in. */
  paneAffinity: number;
  /** If a user has manually opened the specified tab. */
  manuallyOpened: boolean;
}

interface Pane {
  tabs: RuntimeTab[];
  selectedTab: number;
  absIndex: number;
}

const AZUL_MIMETYPE = "application/azul-tab";

@Component({
  selector: "azco-data-tab-panes",
  templateUrl: "./data-tab-panes.component.html",
  changeDetection: ChangeDetectionStrategy.OnPush,
  imports: [
    AzCommonModule,
    PortalModule,
    CommonModule,
    FlowModule,
    FontAwesomeModule,
    AngularSplitModule,
  ],
})
export class DataTabPanesComponent implements OnDestroy {
  private entityService = inject(EntityService);
  private toastrService = inject(ToastrService);

  protected faXmark = faXmark;
  protected faDownload = faDownload;

  protected ButtonType = ButtonType;
  protected ButtonSize = ButtonSize;

  @Input() preTabTemplateRef: TemplateRef<unknown>;

  @Input() set tabs$(value: Observable<TabSpec[]>) {
    this.updateChildren(value);
  }
  private tabsSubscription: Subscription;

  /** Mappings for child elements */
  protected tabList$ = new BehaviorSubject<RuntimeTab[]>([]);

  /** How many panes have been requested */
  protected desiredPaneCount$ = new BehaviorSubject(2);
  /** What tabs are selected for particular panes. */
  protected selectedTabs$ = new BehaviorSubject<number[]>([]);
  /** Available panes */
  protected paneList$: Observable<Pane[]>;
  protected panesWithTabs$: Observable<Pane[]>;
  protected canAddPanes$: Observable<boolean>;

  // This is INCLUSIVE of the left hand sidebar
  private paneSizes$ = new BehaviorSubject<SplitAreaSize[]>([20, "*"]);
  protected validatedPaneSizes$: Observable<SplitAreaSize[]>;

  protected showDragOverlay$ = new BehaviorSubject(false);
  protected hoveredTab$ = new BehaviorSubject<number | undefined>(undefined);
  protected hoveredTabIndex$ = new BehaviorSubject<number | undefined>(
    undefined,
  );

  protected tabDownloading$ = new BehaviorSubject<string | undefined>(
    undefined,
  );
  protected downloading$: Observable<number>;
  protected isDownloading$: BehaviorSubject<boolean> =
    new BehaviorSubject<boolean>(false);

  constructor() {
    const pageWidthWatcher = media("(min-width: 1280px)");

    const actualPaneCount$ = combineLatest([
      this.desiredPaneCount$,
      pageWidthWatcher,
    ]).pipe(
      ops.map(([desiredPanes, enoughWidth]) =>
        enoughWidth ? desiredPanes : 1,
      ),
    );

    this.paneList$ = combineLatest([
      actualPaneCount$,
      this.tabList$,
      this.selectedTabs$,
    ]).pipe(
      ops.map(([paneCount, tabList, selectedTabs]) => {
        // Try to sift available tabs into the available panes we have
        const panes: Pane[] = [];
        for (let i = 0; i < paneCount; i++) {
          panes.push({ tabs: [], selectedTab: 0, absIndex: i });
        }

        for (const tab of tabList) {
          if (tab.open) {
            const tabPane = tab.paneAffinity % panes.length;
            panes[tabPane].tabs.push(tab);
          }
        }

        // Map what tab the user has selected
        for (const [index, pane] of panes.entries()) {
          if (pane.tabs.length > 0) {
            if (index < selectedTabs.length) {
              pane.selectedTab = (selectedTabs[index] ?? 0) % pane.tabs.length;
            }
          }
        }

        return panes;
      }),
      ops.shareReplay(1),
    );

    this.panesWithTabs$ = this.paneList$.pipe(
      ops.map((panes) => panes.filter((pane) => pane.tabs.length > 0)),
    );

    this.canAddPanes$ = combineLatest([
      this.panesWithTabs$,
      actualPaneCount$,
    ]).pipe(
      ops.map(([panes, actualPaneCount]) => panes.length < actualPaneCount),
    );

    this.validatedPaneSizes$ = combineLatest([
      this.paneSizes$,
      this.panesWithTabs$,
    ]).pipe(
      ops.map(([paneSizes, panes]) => {
        if (panes.length === 0) {
          return paneSizes;
        }

        // Angular-split doesn't reliably handle the addition and removal
        // of panes by itself - it assumes a constant number generally.
        // Fix up values coming in so that they make sense:

        // Validate that panes are correctly sized
        const panesPlusSidebar = panes.length + 1;

        // Make sure the sidebar doesn't exceed its maximum size
        if (typeof paneSizes[0] === "number" && paneSizes[0] > 20) {
          paneSizes[0] = 20;
        }

        if (panesPlusSidebar < paneSizes.length) {
          // Old panes have been closed. Combine their width to avoid weird artifacts
          // Set the last pane to be a wildcard
          paneSizes[panes.length] = "*";

          paneSizes = paneSizes.slice(0, panesPlusSidebar);
        } else if (panesPlusSidebar > paneSizes.length) {
          // A new pane has been added - split up the last pane if possible
          const rightmostPaneSize = paneSizes[paneSizes.length - 1];
          if (typeof rightmostPaneSize === "number") {
            // The last pane has fixed sizing - subdivide it
            const newTabCount = panesPlusSidebar - paneSizes.length;
            const rightPaneSizes = rightmostPaneSize / (newTabCount + 1);

            for (let i = paneSizes.length - 1; i < panes.length + 1; i++) {
              paneSizes[i] = rightPaneSizes;
            }
          } else {
            // The last pane is a wildcard - also use wildcards
            for (let i = paneSizes.length; i < panes.length + 1; i++) {
              paneSizes[i] = "*";
            }
          }
        }

        // Finally, convert wildcards to integer values - these don't work
        // reliably with more than one split
        let usedSpace = 0;
        let wildcards = 0;
        for (const paneSize of paneSizes) {
          if (paneSize !== "*") {
            usedSpace += paneSize;
          } else {
            wildcards++;
          }
        }

        if (usedSpace > 100) {
          console.error(
            "Unable to rationalise pane sizing - more than 100% between elements!",
          );

          // As a fallback, reset all panes bar the left one
          paneSizes[0] = 20;
          wildcards = paneSizes.length - 1;
          for (let i = 1; i < paneSizes.length; i++) {
            paneSizes[i] = "*";
          }

          usedSpace = 20;
        }

        if (wildcards > 0) {
          const spacePerSplit = (100 - usedSpace) / wildcards;

          for (let i = 0; i < paneSizes.length; i++) {
            if (paneSizes[i] === "*") {
              paneSizes[i] = spacePerSplit;
            }
          }
        }

        return paneSizes;
      }),
    );
  }

  ngOnDestroy(): void {
    this.tabsSubscription?.unsubscribe();
  }

  /** Updates which tabs are available. */
  private updateChildren(newTabs: Observable<TabSpec[]> | undefined) {
    if (!newTabs) {
      return;
    }

    this.tabsSubscription?.unsubscribe();
    this.tabsSubscription = newTabs.subscribe((newTabs) => {
      const oldTabList = this.tabList$.value;

      // First, filter out any tabs which have been removed
      // This list is small, so optimisations here aren't necessary
      const existingTabs = oldTabList.filter(
        (oldTab) =>
          newTabs.find((newTab) => newTab.tabId === oldTab.tabId) !== undefined,
      );

      // Next, add tabs which are not in the current list
      // Do not update existing tabs, however, as the user might have mutated the tab state for that element
      for (const tabElement of newTabs) {
        const existingTab = existingTabs.find(
          (existingTab) => existingTab.tabId === tabElement.tabId,
        );

        if (existingTab === undefined) {
          existingTabs.push({
            tabId: tabElement.tabId,
            name: tabElement.name,
            betterName$: tabElement?.betterName$,
            open: tabElement.openInPane !== undefined,
            paneAffinity: tabElement.openInPane ?? 0,
            manuallyOpened: false,
            portal: new DomPortal(tabElement.template),
            downloadParent: tabElement.downloadParent,
            downloadHash: tabElement.downloadHash,
          });
        } else {
          // Make updates where it doesn't override user options
          existingTab.name = tabElement.name;
          if (
            !existingTab.manuallyOpened &&
            tabElement.openInPane === undefined
          ) {
            // If this tab was opened by default, but is no longer marked as open, close it
            existingTab.open = false;
            existingTab.paneAffinity = 0;
          }
        }
      }

      this.tabList$.next(existingTabs);
    });
  }

  /** Handles the resize event ending. */
  protected resizeEnd(data: SplitGutterInteractionEvent) {
    this.paneSizes$.next(data.sizes);
  }

  /** Handles a tab click event */
  protected handleTabClick(event: MouseEvent, tabId: string) {
    switch (event.button) {
      case 0:
        // Left click
        this.openTab(tabId);
        break;
      case 1:
        // Middle click
        this.closeTab(tabId);
        event.preventDefault();
        break;
      case 2:
        // Right click
        event.preventDefault();
        break;
    }
  }

  /** Handles a tab click event */
  protected handleTabMouseDown(event: MouseEvent, tabId: string) {
    switch (event.button) {
      case 0:
      case 2:
        // Left/right click - let the click handler handle this
        break;
      case 1:
        // Middle click
        this.closeTab(tabId);
        event.preventDefault();
        break;
    }
  }

  /** Opens or focuses a tab. */
  protected openTab(tabId: string) {
    const tabList = this.tabList$.value;

    const tab = tabList.find((tab) => tab.tabId === tabId);
    if (!tab.open) {
      tab.open = true;
      tab.manuallyOpened = true;
    }

    this.tabList$.next(tabList);

    this.focusTab(tabId);

    // Just incase a drag was triggered.
    this.showDragOverlay$.next(false);
  }

  protected closeTabEvent(event: Event, tabId: string) {
    this.closeTab(tabId);
    // Stop propagation to parent element which would cause the tab to re-open.
    event.stopPropagation();
  }

  protected closeTab(tabId: string) {
    const tabList = this.tabList$.value;

    const tab = tabList.find((tab) => tab.tabId === tabId);
    if (tab.open) {
      tab.open = false;
    }

    this.tabList$.next(tabList);

    // Just incase a drag was triggered.
    this.showDragOverlay$.next(false);
  }

  protected focusTab(tabId: string) {
    this.paneList$.pipe(ops.first()).subscribe((paneList) => {
      const selectedTabs = this.selectedTabs$.value;

      for (const [index, pane] of paneList.entries()) {
        const foundTab = pane.tabs.findIndex(
          (checkTab) => checkTab.tabId === tabId,
        );

        if (foundTab >= 0) {
          selectedTabs[index] = foundTab;
          this.selectedTabs$.next(selectedTabs);
          break;
        }
      }
    });
  }

  /** Populates a browsers native drag and drop with metadata. */
  protected handleTabDragStart(event: DragEvent, tabId: string) {
    // We don't want the browser to allow plain text copying or the like:
    event.dataTransfer.clearData();
    // Inject a fake Azul mime into the data instead:
    event.dataTransfer.setData(AZUL_MIMETYPE, tabId);
    this.showDragOverlay$.next(true);
    this.hoveredTab$.next(undefined);
  }

  /** Hides overlays */
  protected handleTabDragEnd() {
    this.showDragOverlay$.next(false);
  }

  /** Handles a dragged tab entering a drop zone. */
  protected handleDragOver(
    event: DragEvent,
    paneId: number,
    appendNewTab: boolean,
  ) {
    if (event.dataTransfer.types.includes(AZUL_MIMETYPE)) {
      event.preventDefault();
      event.dataTransfer.dropEffect = "copy";
      this.hoveredTab$.next(paneId);
      this.hoveredTabIndex$.next(appendNewTab ? 1 : 0);
    }
  }

  /** Handles a dragged tab leaving the current drop zone. */
  protected handleDragOut() {
    this.hoveredTab$.next(undefined);
    this.hoveredTabIndex$.next(undefined);
  }

  /** Drops a tab into a new pane. */
  protected handleDrop(
    event: DragEvent,
    paneId: number,
    appendNewTab: boolean,
  ) {
    this.hoveredTab$.next(undefined);
    this.hoveredTabIndex$.next(undefined);
    this.showDragOverlay$.next(false);
    event.preventDefault();

    const tabId = event.dataTransfer.getData(AZUL_MIMETYPE);

    console.log(
      "Moving tab",
      tabId,
      "to pane",
      paneId,
      ", appending new pane:",
      appendNewTab,
    );

    const currentTabs = this.tabList$.value;

    if (appendNewTab) {
      // If we are appending a new tab, shuffle any tabs in later panes down 1
      for (const tab of currentTabs) {
        if (tab.paneAffinity > paneId) {
          tab.paneAffinity++;
        }
      }

      // Next, split the current size of the tab in half
      const paneSizes = this.paneSizes$.value;

      let newPaneSizes: SplitAreaSize[] = [];

      for (const [index, paneSize] of paneSizes.entries()) {
        if (index === paneId + 1) {
          if (paneSize === "*") {
            // Wildcard, so just append two wildcards
            newPaneSizes.push("*", "*");
          } else {
            // Fixed width
            newPaneSizes.push(paneSize / 2, paneSize / 2);
          }
        } else {
          newPaneSizes.push(paneSize);
        }
      }

      // Resolve wildcards
      let totalUsedSpace = 0;
      for (const value of newPaneSizes) {
        if (typeof value === "number") {
          totalUsedSpace += value;
        }
      }

      if (totalUsedSpace < 100) {
        // Convert wildcards
        const wildcardCount = newPaneSizes.reduce<number>(
          (sum, x) => (x === "*" ? sum + 1 : sum),
          0,
        );
        const freeSpace = 100 - totalUsedSpace;

        const wildcardSpace = freeSpace / wildcardCount;

        newPaneSizes = newPaneSizes.map((x) => (x === "*" ? wildcardSpace : x));
      }

      this.paneSizes$.next(newPaneSizes);
    }

    // Try to find this tab
    const tabToMove = currentTabs.find((tab) => tab.tabId === tabId);

    if (tabToMove) {
      tabToMove.paneAffinity = appendNewTab ? paneId + 1 : paneId;
    } else {
      console.warn("Failed to find tab to move - multiple Azul windows open?");
    }

    this.tabList$.next(currentTabs);

    this.focusTab(tabId);
  }

  protected downloadFile(tabId: string, parent: string, hash: string) {
    this.tabDownloading$.next(tabId);
    this.downloading$ = this.entityService.download(hash, undefined);
    this.isDownloading$.next(true);
    this.downloading$.subscribe({
      next: () => {},
      complete: () => {
        this.isDownloading$.next(false);
      },
      error: (e: HttpErrorResponse) => {
        console.log("handle error");
        let msg = "Unable to download file.";
        if (e.status === 404) {
          msg = "Unable to download file, it is likely not in storage.";
        }
        this.toastrService.warning(
          msg,
          `Failed to Download status: '${e.status}'`,
        );
        this.isDownloading$.next(false);
      },
    });
  }
}
